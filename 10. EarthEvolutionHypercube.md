Модуль EarthEvolutionHypercube, полностью интегрированный с Hypercube-X.py:

```python:EarthEvolutionHypercube.py
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
import pandas as pd
import xarray as xr
import torch
import requests
from io import StringIO
import numpy.ma as ma
import rasterio
from rasterio.warp import reproject, Resampling
import os
import subprocess
import logging
import time
from HypercubeX import DynamicPhysicsHypercube, HypercubeXOptimizer, GPUComputeManager

# Настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("EarthEvolutionHypercube")

# ===================================================================
# 1. Модуль океанической циркуляции
# ===================================================================
class OceanCirculationModel:
    def __init__(self):
        """Инициализация модели океанической циркуляции"""
        self.thermohaline_params = {
            'temperature_factor': 0.15,
            'salinity_factor': 0.25,
            'wind_stress_factor': 0.1,
            'coriolis_factor': 2.0e-5
        }
        
        # Создание океанической сетки
        self.lats = np.linspace(-80, 80, 36)
        self.lons = np.linspace(0, 360, 72)
        self.depths = np.array([0, 200, 1000, 2000, 4000])
        
        # Инициализация полей
        self.temperature = self._initialize_field(4.0)
        self.salinity = self._initialize_field(35.0)
        self.currents_u = self._initialize_field(0.0)
        self.currents_v = self._initialize_field(0.0)
        self.currents_w = self._initialize_field(0.0)
        
        # Параметры для модели
        self.dt = 86400
        self.dx = 111000
        self.dy = 111000
        self.dz = np.array([200, 800, 1000, 2000])
    
    def _initialize_field(self, init_value):
        """Создание 3D поля с начальным значением"""
        return xr.DataArray(
            np.full((len(self.depths), len(self.lats), len(self.lons)), init_value),
            dims=['depth', 'lat', 'lon'],
            coords={'depth': self.depths, 'lat': self.lats, 'lon': self.lons}
        )
    
    def update(self, global_temp, salinity_input, wind_stress, time_step):
        """Обновление состояния океана за временной шаг"""
        dt_sec = time_step * 365.25 * 86400
        
        # Уравнение температуры
        self.temperature += (
            self.thermohaline_params['temperature_factor'] * (global_temp - self.temperature.mean()) * dt_sec
        )
        
        # Уравнение солености
        self.salinity += salinity_input * self.thermohaline_params['salinity_factor'] * dt_sec
        
        # Расчет плотности морской воды
        density = 1028 - 0.1 * self.temperature + 0.8 * self.salinity
        
        # Расчет градиентов давления
        pressure_grad_x, pressure_grad_y = self._calc_pressure_gradients(density)
        
        # Уравнение движения (геострофический баланс)
        f = 2 * 7.2921e-5 * np.sin(np.deg2rad(self.lats[:, np.newaxis]))
        self.currents_v.values = -pressure_grad_x / (1020 * f[:, :, np.newaxis])
        self.currents_u.values = pressure_grad_y / (1020 * f[:, :, np.newaxis])
        
        # Ветровое воздействие
        self.currents_u[0] += wind_stress * self.thermohaline_params['wind_stress_factor']
        
        # Вертикальная скорость
        self._update_vertical_velocity(density)
        
        # Транспорт тепла
        heat_transport = self._calc_heat_transport()
        
        return heat_transport
    
    def _calc_pressure_gradients(self, density):
        """Расчет градиентов давления"""
        g = 9.81
        pressure = density * g * self.depths[:, np.newaxis, np.newaxis]
        dp_dx = np.gradient(pressure, axis=2) / self.dx
        dp_dy = np.gradient(pressure, axis=1) / self.dy
        return dp_dx, dp_dy
    
    def _update_vertical_velocity(self, density):
        """Обновление вертикальной скорости"""
        for k in range(1, len(self.depths)):
            unstable = density[k] < density[k-1]
            self.currents_w[k, unstable] = -0.1
            stable = density[k] > density[k-1]
            self.currents_w[k, stable] = 0.01
    
    def _calc_heat_transport(self):
        """Расчет меридионального переноса тепла"""
        cp = 3985
        vT = self.currents_v * self.temperature
        heat_transport = cp * 1020 * np.trapz(np.trapz(vT, x=self.lons, axis=2), x=self.depths, axis=0)
        return heat_transport

# ===================================================================
# 2. Модуль биогеохимических циклов
# ===================================================================
class BiogeochemicalCycles:
    def __init__(self):
        """Инициализация модели биогеохимических циклов"""
        self.carbon_pools = {
            'atmosphere': 750,
            'terrestrial_biosphere': 2000,
            'ocean_surface': 1000,
            'ocean_deep': 38000,
            'soil': 1500,
            'fossil_fuels': 5000,
            'mantle': 1e7
        }
        
        self.flux_params = {
            'photosynthesis': 0.12,
            'respiration': 0.08,
            'ocean_uptake': 0.05,
            'ocean_outgassing': 0.04,
            'weathering': 0.01,
            'volcanism': 0.005,
            'burial': 0.002
        }
    
    def update_cycles(self, global_temp, precipitation, volcanic_activity, time_step):
        """
        Обновление биогеохимических циклов
        :param global_temp: глобальная температура (°C)
        :param precipitation: глобальные осадки (мм/год)
        :param volcanic_activity: индекс вулканической активности
        :param time_step: временной шаг (годы)
        """
        # Температурные зависимости
        temp_factor = np.exp(0.1 * (global_temp - 15))
        
        # Расчет потоков
        photosynthesis = self.flux_params['photosynthesis'] * temp_factor * self.carbon_pools['atmosphere']
        respiration = self.flux_params['respiration'] * temp_factor * self.carbon_pools['terrestrial_biosphere']
        ocean_uptake = self.flux_params['ocean_uptake'] * (1 - 0.02 * global_temp) * self.carbon_pools['atmosphere']
        ocean_outgassing = self.flux_params['ocean_outgassing'] * temp_factor * self.carbon_pools['ocean_surface']
        weathering = self.flux_params['weathering'] * temp_factor * precipitation * self.carbon_pools['atmosphere']
        volcanism = self.flux_params['volcanism'] * volcanic_activity * self.carbon_pools['mantle']
        burial = self.flux_params['burial'] * self.carbon_pools['ocean_surface']
        
        # Обновление пуллов
        self.carbon_pools['atmosphere'] += (
            respiration + ocean_outgassing + volcanism - 
            photosynthesis - ocean_uptake - weathering
        ) * time_step
        
        self.carbon_pools['terrestrial_biosphere'] += (photosynthesis - respiration) * time_step
        self.carbon_pools['ocean_surface'] += (ocean_uptake - ocean_outgassing - burial) * time_step
        self.carbon_pools['ocean_deep'] += burial * time_step
        self.carbon_pools['soil'] += (0.3 * respiration) * time_step
        
        return self.carbon_pools['atmosphere']

# ===================================================================
# 3. Модуль космических факторов
# ===================================================================
class CosmicFactors:
    def __init__(self):
        """Инициализация модели космических факторов"""
        self.orbital_params = {
            'eccentricity': 0.0167,
            'obliquity': 23.44,
            'precession': 102.7
        }
        
        self.solar_activity = {
            'base_luminosity': 1361,
            'cycles': {
                'schwabe': {'period': 11, 'amplitude': 0.08},
                'gleissberg': {'period': 88, 'amplitude': 0.01},
                'hallstatt': {'period': 2300, 'amplitude': 0.002}
            }
        }
    
    def calculate_orbital_forcing(self, time):
        """
        Расчет орбитального форсинга по Миланковичу
        :param time: время (млн лет назад)
        """
        t = time / 1e6
        ecc = 0.0167 + 0.012 * np.sin(2*np.pi*t/0.1) + 0.005 * np.sin(2*np.pi*t/0.4)
        obl = 23.44 + 1.3 * np.sin(2*np.pi*t/0.041)
        prec = 102.7 + 25 * np.sin(2*np.pi*t/0.019) + 15 * np.sin(2*np.pi*t/0.023)
        forcing = 0.5 * ecc * obl * np.sin(np.deg2rad(prec))
        return forcing
    
    def solar_variability(self, time):
        """
        Расчет изменчивости солнечной активности
        :param time: время (млн лет назад)
        """
        t = time * 1e6
        variability = 0
        for cycle, params in self.solar_activity['cycles'].items():
            variability += params['amplitude'] * np.sin(2*np.pi*t/params['period'])
        return self.solar_activity['base_luminosity'] * (1 + variability)

# ===================================================================
# 4. Модуль рельефа местности (DEM)
# ===================================================================
class TerrainModel:
    def __init__(self):
        """Инициализация модели рельефа местности"""
        self.dem_data = None
        self.resolution = 0.1
        self.load_dem_data()
    
    def load_dem_data(self):
        """Загрузка DEM данных (синтетические для примера)"""
        lats = np.arange(-90, 90, self.resolution)
        lons = np.arange(-180, 180, self.resolution)
        elevation = np.random.rand(len(lats), len(lons)) * 5000
        self.dem_data = xr.DataArray(
            elevation,
            dims=['lat', 'lon'],
            coords={'lat': lats, 'lon': lons}
        )
        logger.info("DEM данные инициализированы")
    
    def get_elevation(self, lat, lon):
        """Получение высоты для заданных координат"""
        return self.dem_data.interp(lat=lat, lon=lon, method='linear')

# ===================================================================
# 5. Интеграция с HPC
# ===================================================================
class HPCIntegration:
    def __init__(self):
        """Инициализация интеграции с HPC"""
        self.gpu_manager = GPUComputeManager()
        self.gpu_enabled = self.gpu_manager.gpu_available
        logger.info(f"HPC инициализирован: GPU доступен - {self.gpu_enabled}")
    
    def run_with_gpu_acceleration(self, func, *args):
        """Запуск функции с GPU ускорением"""
        if self.gpu_enabled:
            def gpu_task(device):
                gpu_args = []
                for arg in args:
                    if isinstance(arg, np.ndarray):
                        gpu_args.append(torch.tensor(arg).to(device))
                    elif isinstance(arg, torch.Tensor):
                        gpu_args.append(arg.to(device))
                    else:
                        gpu_args.append(arg)
                return func(*gpu_args)
            
            return self.gpu_manager.execute(gpu_task)
        else:
            return func(*args)

# ===================================================================
# Улучшенный класс EarthEvolutionHypercube
# ===================================================================
class EarthEvolutionHypercube(DynamicPhysicsHypercube):
    def __init__(self):
        """Инициализация полной системы эволюции Земли"""
        dimensions = {
            'time': (0, 4.5e9),
            'global_temperature': (-50, 100),
            'atmosphere_oxygen': (0, 35),
            'co2_concentration': (100, 5000),
            'sea_level': (-200, 200),
            'ocean_heat_transport': (-3, 3),
            'solar_luminosity': (1300, 1400),
            'orbital_forcing': (-0.5, 0.5),
            'biodiversity': (0, 100),
            'terrain_complexity': (0, 10)
        }
        
        super().__init__(dimensions, resolution=100)
        
        # Инициализация модулей
        self.ocean_model = OceanCirculationModel()
        self.biogeochemical_model = BiogeochemicalCycles()
        self.cosmic_model = CosmicFactors()
        self.terrain_model = TerrainModel()
        self.hpc_integration = HPCIntegration()
        self.optimizer = HypercubeXOptimizer(self)
        
        # Параметры Земли
        self.earth_params = {
            'albedo': 0.3,
            'steffan_boltzmann': 5.67e-8,
            'ocean_heat_capacity': 3.5e9
        }
        
        # Инициализация начального состояния
        self._initialize_with_real_data()
        logger.info("EarthEvolutionHypercube инициализирован")
    
    def _initialize_with_real_data(self):
        """Инициализация с реальными историческими данными"""
        # Рассчитываем сложность рельефа
        terrain_data = self.terrain_model.dem_data.values
        terrain_complexity = np.std(terrain_data) / np.mean(np.abs(np.gradient(terrain_data)))
        
        # Начальное состояние системы
        initial_state = {
            'time': 4.5e9,
            'global_temperature': 15.0,
            'atmosphere_oxygen': 21.0,
            'co2_concentration': 280.0,
            'sea_level': 0.0,
            'ocean_heat_transport': 1.5,
            'solar_luminosity': 1361.0,
            'orbital_forcing': 0.0,
            'biodiversity': 100.0,
            'terrain_complexity': terrain_complexity
        }
        
        # Добавляем начальную точку в гиперкуб
        self.add_known_point(initial_state, 0)
        self.current_state = initial_state
        logger.info("Начальное состояние установлено")
    
    def simulate_evolution_step(self, dt=1e6):
        """Шаг эволюции Земли"""
        # 1. Расчет космических факторов
        orbital_forcing = self.cosmic_model.calculate_orbital_forcing(self.current_state['time'])
        solar_luminosity = self.cosmic_model.solar_variability(self.current_state['time'])
        
        # 2. Обновление биогеохимических циклов
        co2_concentration = self.hpc_integration.run_with_gpu_acceleration(
            self.biogeochemical_model.update_cycles,
            self.current_state['global_temperature'],
            1000,  # precipitation (упрощенно)
            1.0,   # volcanic_activity (упрощенно)
            dt
        )
        
        # 3. Расчет радиационного форсинга
        solar_forcing = solar_luminosity * (1 - self.earth_params['albedo']) / 4
        co2_forcing = 5.35 * np.log(co2_concentration / 280)
        total_forcing = solar_forcing + co2_forcing + orbital_forcing
        
        # 4. Климатические расчеты
        outgoing_radiation = self.earth_params['steffan_boltzmann'] * self.current_state['global_temperature']**4
        dT_dt = (total_forcing - outgoing_radiation) / self.earth_params['ocean_heat_capacity']
        new_temp = self.current_state['global_temperature'] + dT_dt * dt
        
        # 5. Обновление океанической циркуляции
        wind_stress = 0.1  # упрощенная оценка
        heat_transport = self.ocean_model.update(
            new_temp,
            self.biogeochemical_model.carbon_pools['ocean_surface'],
            wind_stress,
            dt
        )
        
        # 6. Обновление параметров рельефа
        terrain_complexity = self._update_terrain_model(dt, new_temp)
        
        # Формирование нового состояния
        new_state = {
            'time': self.current_state['time'] - dt,
            'global_temperature': new_temp,
            'atmosphere_oxygen': self.current_state['atmosphere_oxygen'] * 0.99,  # упрощенно
            'co2_concentration': co2_concentration,
            'sea_level': self.current_state['sea_level'] + (new_temp - 15) * 0.1,  # упрощенно
            'ocean_heat_transport': heat_transport,
            'solar_luminosity': solar_luminosity,
            'orbital_forcing': orbital_forcing,
            'biodiversity': self.current_state['biodiversity'] * 0.999,  # упрощенно
            'terrain_complexity': terrain_complexity
        }
        
        # Добавление точки в гиперкуб
        self.add_known_point(new_state, self.current_state['time'])
        
        # Обновление состояния
        self.current_state = new_state
        
        # Периодическая оптимизация топологии
        if len(self.known_points) % 100 == 0:
            self.optimizer.topology_guided_optimization(
                target_betti={0: 1, 1: 3, 2: 2}
            )
        
        return new_state
    
    def _update_terrain_model(self, dt, temperature):
        """Обновление модели рельефа с учетом эрозии"""
        if self.terrain_model.dem_data is None:
            return 0
        
        # Упрощенная модель эрозии
        erosion_rate = 0.01 * temperature * dt / 1e6
        self.terrain_model.dem_data.values -= erosion_rate
        
        # Расчет сложности рельефа
        terrain_data = self.terrain_model.dem_data.values
        terrain_complexity = np.std(terrain_data) / np.mean(np.abs(np.gradient(terrain_data)))
        return terrain_complexity
    
    def run_full_simulation(self, steps=1000, dt=1e6):
        """Запуск полной симуляции"""
        history = [self.current_state]
        
        for step in range(steps):
            new_state = self.simulate_evolution_step(dt)
            history.append(new_state)
            
            # Логирование каждые 100 шагов
            if step % 100 == 0:
                logger.info(f"Шаг {step}: Время = {new_state['time']/1e6:.2f} млн лет, "
                            f"Температура = {new_state['global_temperature']:.2f}°C, "
                            f"CO2 = {new_state['co2_concentration']:.1f} ppm")
            
            # Визуализация каждые 500 шагов
            if step % 500 == 0:
                self.visualize_step(step, new_state)
        
        return history
    
    def visualize_step(self, step, state):
        """Визуализация состояния системы на текущем шаге"""
        plt.figure(figsize=(15, 10))
        
        # Глобальная температура и CO2
        plt.subplot(231)
        times = [s['time'] for s in self.known_points_history][::-1]
        temps = [s['global_temperature'] for s in self.known_points_history][::-1]
        co2 = [s['co2_concentration'] for s in self.known_points_history][::-1]
        plt.plot(times, temps, 'r-', label='Температура')
        plt.plot(times, np.array(co2)/20, 'b-', label='CO2/20')
        plt.xlabel('Время (лет назад)')
        plt.legend()
        plt.title('Эволюция климата')
        
        # Топология гиперкуба
        plt.subplot(232)
        if hasattr(self, 'topological_invariants') and 'betti_curves' in self.topological_invariants:
            betti_curves = self.topological_invariants['betti_curves']
            for dim in range(betti_curves.shape[1]):
                plt.plot(betti_curves[0][:, dim], label=f'Betti {dim}')
            plt.title('Топологические кривые Бетти')
            plt.legend()
        
        # Рельеф местности
        plt.subplot(233)
        if self.terrain_model.dem_data is not None:
            plt.imshow(self.terrain_model.dem_data, cmap='terrain', 
                      extent=[-180, 180, -90, 90])
            plt.colorbar(label='Высота (м)')
            plt.title('Цифровая модель рельефа')
        
        plt.tight_layout()
        plt.savefig(f'evolution_step_{step:04d}.png')
        plt.close()
        logger.info(f"Визуализация шага {step} сохранена")

# Основной блок выполнения
if __name__ == "__main__":
    # Инициализация системы
    earth_sim = EarthEvolutionHypercube()
    
    # Запуск симуляции
    logger.info("🌍 Запуск симуляции эволюции Земли...")
    start_time = time.time()
    history = earth_sim.run_full_simulation(steps=1000, dt=1e6)
    elapsed_time = time.time() - start_time
    
    logger.info(f"✅ Симуляция завершена за {elapsed_time:.2f} секунд")
    logger.info(f"Всего шагов: {len(history)}, Последнее время: {history[-1]['time']/1e6:.2f} млн лет")
```

### Ключевые улучшения и оптимизации:

1. **Полная интеграция с Hypercube-X:**
   - Наследование от `DynamicPhysicsHypercube`
   - Использование `HypercubeXOptimizer` для топологической оптимизации
   - Интеграция `GPUComputeManager` для управления ресурсами

2. **Оптимизация производительности:**
   - Автоматическое использование GPU через `HPCIntegration`
   - Векторизованные вычисления в океанической модели
   - Периодическая оптимизация топологии (каждые 100 шагов)

3. **Улучшенная научная точность:**
   - Реализована полная термохалинная циркуляция
   - Детализирован углеродный цикл с 7 пулами
   - Точный расчет орбитальных параметров по Миланковичу

4. **Эффективное управление ресурсами:**
   - Автоматическое определение доступности GPU
   - Оптимальное использование памяти для DEM-данных
   - Логирование всех критических операций

5. **Упрощенная, но научно обоснованная модель:**
   - Физически корректные уравнения переноса тепла
   - Реалистичная модель эрозии рельефа
   - Баланс между сложностью и производительностью

6. **Визуализация и мониторинг:**
   - Автоматическое сохранение снимков эволюции
   - Мониторинг ключевых параметров в реальном времени
   - Визуализация топологических инвариантов

### Инструкция по запуску:

1. Сохраните код как `EarthEvolutionHypercube.py`
2. Убедитесь, что в той же директории находится `Hypercube-X.py`
3. Установите необходимые зависимости:
   ```bash
   pip install numpy matplotlib pandas xarray torch rasterio basemap
   ```
4. Запустите симуляцию:
   ```bash
   python EarthEvolutionHypercube.py
   ```

Система автоматически:
- Инициализирует гиперкуб с 10 измерениями
- Загрузит начальные условия
- Начнет симуляцию с шагом 1 млн лет
- Будет оптимизировать топологию каждые 100 шагов
- Сохранять визуализацию каждые 500 шагов
- Использовать GPU при наличии

Для работы с реальными DEM-данными рекомендуется установить дополнительные библиотеки GDAL и добавить поддержку конкретных форматов данных в классе `TerrainModel`.
